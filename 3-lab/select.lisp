(require 'asdf)
(load "cl-simple-table-master/cl-simple-table.asd")
(asdf:load-system 'cl-simple-table)
; maybe instead of functions from this package I will write my own function

(load "distinct.lisp")
(load "stack/stack.lisp")
(load "functions.lisp")
(load "importer.lisp")

(defun generateColumn (len val)
  (make-array len :initial-element val)
  )

(defun generateValue (value table)
  ;(concatenate 'string "[value:" (write-to-string value) "]")
  (let ((col (generateColumn (table-len table) value)))
	(lambda ()
	  col
	  )
	)
  )

(defun selectCoumn (index data)
  (reduce (lambda (column row)
			(vector-push-extend (aref row index) column)
			column
			)
		  data
		  :initial-value (make-array 0 :fill-pointer 0))
  )

(defun generateColumnValue (colname table)
  ;(concatenate 'string "[column:" colname "]")
  (setf colname (nth 0 (gethash colname (table-columnIndexes table))))
  (let ((col (selectCoumn colname (table-data table))))
	(lambda ()
	  col
	  )
	)
  )

(defun appendValue (lst value)
  (append lst (list value))
  )

(defun generateFunction (fnname args)
  (let ((fn (getFunction fnname)))
	(lambda ()
	  (apply fn args)
	  )
	)
  )

(defun ifOperator (ch)
  (cond
	((or (char= #\+ ch)
		 (char= #\- ch)
		 (char= #\* ch)
		 (char= #\/ ch)
		 (char= #\( ch)
		 (char= #\) ch)
		 (char= #\, ch)) t)
	(t nil)
	)
  )

(defun getPriority (fn)
  (cond
	((string= fn "=") 10)
	((or (string= fn "*")
		 (string= fn "/")) 8)
	((or (string= fn "+")
		 (string= fn "-")) 7)
	((string= fn "(") 6)
	(t 9)
	)
  )

(defun insertClosingBracket (operators stack)
  (let ((topOperator (stack-top stack)))
	(cond
	  ((string= topOperator "(")
	   (stack-pop stack)
	   operators)
	  (t (insertClosingBracket (appendValue operators topOperator) (stack-pop stack)))
	  )
	)
  )

(defun insertComa (operators stack)
  (let ((topOperator (stack-top stack)))
	(cond
	  ((stack-is-empty stack) (appendValue operators ","))
	  ((string= topOperator "(") operators)
	  (t (insertComa (appendValue operators topOperator) (stack-pop stack)))
	  )
	)
  )

(defun insertOperator (operator operators stack)
  (let ((topOperator (stack-top stack)))
	(cond
	  ((string= operator "(")
	   (stack-push operator stack)
	   operators)
	  ((stack-is-empty stack)
	   (stack-push operator stack)
	   operators)
	  ((>= (getPriority topOperator) (getPriority operator))
	   (insertOperator operator (appendValue operators topOperator) (stack-pop stack)))
	  (t (stack-push operator stack)
		 operators)
	  )
	)
  )

(defun insertOperatorInStack (operator operators stack)
  (let ((topOperator (stack-top stack)))
	(cond
	  ((string= operator ")") (insertClosingBracket operators stack))
	  ((string= operator ",") (insertComa operators stack))
	  (t (insertOperator operator operators stack))
	  )
	)
  )

(defun clearStack (operators stack)
  (cond
	((stack-is-empty stack)
	 operators)
	(t (clearStack (appendValue operators (stack-top stack)) (stack-pop stack)))
	)
  )

(defun ifNameChar (ch)
  (setf ch (char-int ch))
  (cond
	((or (and (>= ch 48) (<= ch 57))
		 (and (>= ch 65) (<= ch 90))
		 (and (>= ch 97) (<= ch 122))) t)
	(t nil)
	)
  )

(defun readName (selectStr operators stack table)
  (let ((nameEnd (position-if-not #'ifNameChar selectStr)))
	(cond
	  ((not nameEnd)
	   (setf operators (appendValue operators (generateColumnValue selectStr table)))
	   (parseSelect "" operators stack table))
	  ((char= #\( (char selectStr nameEnd))
	   (let ((funName (subseq selectStr 0 nameEnd)))
	      (setf operators (insertOperatorInStack funName operators stack))
	      (setf selectStr (string-left-trim " " (subseq selectStr nameEnd)))
	      (parseSelect selectStr operators stack table)
		  ))
	  (t (pprint "readname - column")
		 (setf operators (appendValue operators (generateColumnValue (subseq selectStr 0 nameEnd) table)))
		 (setf selectStr (string-left-trim " " (subseq selectStr nameEnd)))
		 (parseSelect selectStr operators stack table))
	  )
	)
  )

(defun readStringValue (selectStr operators stack table)
   (let ((value (subseq selectStr 1 (position #\' selectStr :start 1))))
	 (setf selectStr (string-left-trim " " (subseq selectStr (+ (length value) 2))))
	 (setf operators (appendValue operators (generateValue value table)))
	 (parseSelect selectStr operators stack table)
	 )
  )

(defun readIntValue (selectStr operators stack table)
  (let ((value (subseq selectStr 0 (position-if-not #'digit-char-p selectStr))))
	(setf selectStr (string-left-trim " " (subseq selectStr (length value))))
	(setf operators (appendValue operators (generateValue (read-from-string value) table)))
	(parseSelect selectStr operators stack table)
	)
  )

(defun readOperator (selectStr operators stack table)
  (let ((ch (subseq selectStr 0 1)))
    (setf selectStr (string-left-trim " " (subseq selectStr 1)))
    (parseSelect selectStr (insertOperatorInStack ch operators stack) stack table)
	)
  )

(defun parseSelect (selectStr operators stack table)
  (cond
	((string= selectStr "")
     (clearStack operators stack))
	(t
      (let ((ch (char selectStr 0)))
        (cond
  	      ((digit-char-p ch)
		   (readIntValue selectStr operators stack table))
  	      ((char= #\' ch)
		   (readStringValue selectStr operators stack table))
          ((ifOperator ch)
		   (readOperator selectStr operators stack table))
	      ((ifNameChar ch)
		   (readName selectStr operators stack table))
	      (t nil)
  	      )
		)
	  )
	)
  )

(defun removeLast (lst n)
  (remove-if (constantly t) lst :count n :from-end t)
  )

(defun buildFunctions (prevOperators nextOperators)
  (let ((next (car nextOperators)))
	(cond
	  ((not nextOperators) prevOperators)
	  ((functionp next)
	   (buildFunctions (appendValue prevOperators next) (cdr nextOperators)))
	  ((stringp next)
	   (cond
		 ((string= next ",")
		  (buildFunctions prevOperators (cdr nextOperators)))
		 (t (let ((paramAmount (getArgumentAmount next)))
			  (buildFunctions (appendValue (removeLast prevOperators paramAmount)
										   (generateFunction next (last prevOperators paramAmount)))
							  (cdr nextOperators))
			  ))
		 ))
	  (t (pprint "DEFAULT CASE")
		 nil)
	  )
	)
  )

;(defvar fn (buildFunctions '() (parseSelect "1 + 6 * (3 + 6)" '() (make-stack) nil)))
(defvar simple (make-table :tableName "test"
						   :columnNames '("col1" "col2" "col3")
						   :columnIndexes (makeIndexHashMap #("col1" "col2" "col3"))
						   :data #(#(1 "pasha" 61)
								   #(2 "pacha" 98)
								   #(3 "asan" 645)
								   #(4 "yter" 5)
								   #(5 "qkation" 15)
								   )))
(defun test (str)
  (let ((fn (buildFunctions '() (parseSelect str
											 '()
											 (make-stack)
											 simple))))
	(pprint (funcall (nth 0 fn)))
	)
  )

(test "col3")
(test "col1 + 1")
(test "concat('name is: ', col2)")

#||
(pprint (parseSelect "1 + 3*(fn('value', id, 3) +2) - 4" '() (make-stack) nil))
(pprint (parseSelect "1 + 3*(fn('value', 43 + id * 6, 3) +2) - 4" '() (make-stack) nil))
(pprint (parseSelect "1 + 3*(fn('value', 43 + count(id) * 6, 3) +2) - 4" '() (make-stack) nil))
(pprint (parseSelect "concat(name, ' ', description)" '() (make-stack) nil))
(pprint (parseSelect "col1" '() (make-stack) nil))
(pprint (parseSelect "2 +id" '() (make-stack) nil))
(pprint (parseSelect "col1, 2 + id, concat('name is: ', name)" '() (make-stack) nil))
(pprint (parseSelect "3+6*5, pow(2 + id, 2) + 3, concat('name is: ', name)" '() (make-stack) nil))
;||#

